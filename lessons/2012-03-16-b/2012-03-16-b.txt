% Polyhedral geometry 3
% Computational Visual Design ([CVD-Lab](https://github.com/cvd-lab)), DIA, "Roma Tre" University, Rome, Italy 
% Computational Graphics 2012


# Examples and Exercises


## PLaSM Basics 

**PLaSM** = Geometric extension of the *FP* / *FL* languages by **Backus** (IBM Research)

> A. Paoluzzi, V. Pascucci and M. Vicentino: Geometric Programming: A Programming Approach to Geometric Design. ACM Transactions on Graphics 14(3): 266-306 (1995)

#.	geometric calculus in FL-style 

#.	dimension independence

#.	dynamic typing

#.	higher-level operators 

#.	arity: always 1 (number of arguments of functions)

#.	small set of predefined functionals

#.	names of functions: all-caps 


## PLaSM Basics (AA: Apply-to-All)

~~~~~~~~~javascript
AA(SUM) [[1,2,3],[4,5,6]]
=> [6,15] 
~~~~~~~~~javascript


## PLaSM Basics (DISTL: DISTribute-Left)

~~~~~~~~~javascript
DISTL [2,[1,2,3]] 
// => [[2,1],[2,2],[2,3]] 

DISTL [2,[]] 
// => [] 
~~~~~~~~~javascript


## PLaSM Basics (TRANS: TRANSpose)

~~~~~~~~~javascript
TRANS [[1,2,3],[10,20,30],[100,200,300]] 
// => [[1,10,100],[2,20,200],[3,30,300]] 

TRANS [[1,2,3,4,5],[10,20,30,40,50]] 
// => [[1,10],[2,20],[3,30],[4,40],[5,50]] 

TRANS [[],[]] 
// => [] 
~~~~~~~~~javascript


## PLaSM Basics (arithmetic ops)

~~~~~~~~~javascript
MUL [3,4]
// => MUL [3,4] = 12 

MUL [[1,2,3],[4,5,6]]
// => MUL [[1,2,3],[4,5,6]] = [4, 10, 18] 
~~~~~~~~~javascript

~~~~~~~~~javascript
SUM [3,4]
// => SUM [3,4] = 7 

SUM [[1,2,3],[4,5,6]]
// => SUM [[1,2,3],[4,5,6]] = [5, 7, 9] 
~~~~~~~~~javascript


## PLaSM Basics (product scalar by vector)

~~~~~~~~~javascript
PROD [3,[1,2,3]]
// => PROD [3,[1,2,3]] = [3, 6, 9] 

PROD [4,[10,20,30]]
// => PROD [4,[10,20,30]] = [40, 80, 120] 
~~~~~~~~~javascript



## Plasm.js: Exercise 1 (INNERPROD)

The *inner (or scalar) product* of $a,b \in \R^m$ is a number
$$
\mbox{\tt INNERPROD}: \R^m\times\R^m \rightarrow \R : (u, v) \mapsto \sum_{i=1}^m \v{u}_i \v{v}_i 
$$

~~~~~~~~~javascript
INNERPROD = ([u, v]) -> SUM MUL [u, v]

u = [1,2,3]
v = [10,20,30]
INNERPROD [u, v]
// => 140
~~~~~~~~~javascript


## Plasm.js: Exercise 2 (VECTNORM)


The *norm* of a vector $a \in \R^m$ is a number.
$$
\mbox{\tt VECTNORM}: \R^m \rightarrow \R : v \mapsto \sqrt{ \sum_{i=1}^m \v{v}_i^2 }
$$

~~~~~~~~~javascript
VECTNORM = (v) -> Math.sqrt SUM MUL [v, v]

a = [1,2,3]
VECTNORM a
// => 3.7416573867739413 
~~~~~~~~~javascript



## Plasm.js: Exercise 3 (UNITVECT)

The *unit vector* is a function
$$
\mbox{\tt UNITVECT}: \R^m \rightarrow \R^m : v \mapsto \frac{v}{\|v\|}
$$

~~~~~~~~~javascript
UNITVECT = (v) -> PROD [1/(VECTNORM v), v]

v = [1,2,3]
UNITVECT v
// => [0.2672612, 0.5345224, 0.8017837]

VECTNORM UNITVECT v
// => 1 
~~~~~~~~~javascript




## Plasm.js: Exercise 4 (SUM)

SUM adds $n$ vectors in $\R^m$, i.e. the columns of a matrix in $\R^m_n$:

~~~~~~~~~javascript
a = [1,2,3]
a
// => [1, 2, 3] 

b = [10,20,30]
b
// => [10, 20, 30] 
~~~~~~~~~javascript

~~~~~~~~~javascript
SUM [a,b]
// => SUM [a,b] = [11, 22, 33] 
~~~~~~~~~javascript

## Plasm.js: Exercise 5 (SUM)

~~~~~~~~~javascript
a = [1..10]
a
// => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 

b =  (10*k for k in [1..10])
b
// => [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

SUM [a,b]
// => [11, 22, 33, 44, 55, 66, 77, 88, 99, 110] 
~~~~~~~~~javascript

~~~~~~~~~javascript
c =  (100*k for k in [1..10])
SUM [a,b,c]
// => [111, 222, 333, 444, 555, 666, 777, 888, 999, 1110] 
~~~~~~~~~javascript


## Plasm.js: Exercise 6 (MATSUM)

Write a function that adds any two matrices $[A],[B]$ (compatible by sum).
both $[A], [B]$ must belong to the same linear space $\R^m_n$

~~~~~~~~~javascript
MATSUM = (args) -> AA(AA(SUM)) AA(TRANS) TRANS args
~~~~~~~~~javascript

~~~~~~~~~javascript
A = [ [1,2,3], [4,5,6], [7,8,9] ]
B = [ [10,20,30], [40,50,60], [70,80,90] ]

MATSUM [A,B]
// => [ [11,22,33], [44,55,66], [77,88,99] ]

MATSUM [A,B,A]
// => [ [12,24,36], [48,60,72], [84,96,108] ]

MATSUM [A,B,B,A]
// => [ [22,44,66], [88,110,132], [154,176,198] ]
~~~~~~~~~javascript


## Plasm.js: Exercise 7 (MATPROD)

Write a function that multiplies two matrices  (compatible by product)

Remember that
$$ A \in \R^m_n,\quad B \in \R^n_p, \quad\mbox{and}\quad C = AB \in \R^m_p, $$
with
$$
C = \mat{ c^i_j } = \mat{ \T{A^i} \T{B_j} }, \qquad 1\leq i\leq m, 1\leq j\leq p,
$$

where $\T{A^i}$ is the $i$-th row of $\T{A}$, and $\T{B_j}$ is the $j$-th column of $\T{B}$.




## Plasm.js: Exercise 7 (MATPROD) -- Solution

Write a function that multiplies two compatible matrices

~~~~~~~~~javascript
MATPROD = ([A,B]) -> 
	AA(AA(INNERPROD)) AA(DISTL) DISTR [A, TRANS B]
~~~~~~~~~javascript

~~~~~~~~~javascript
A = [[1,2,3],[4,5,6],[7,8,9]]
B = [[1,2,3],[4,5,6],[7,8,9]]
MATPROD [A,B]
// => [ [30, 36, 42], [66,81,96], [102,126,150] ]
~~~~~~~~~javascript

~~~~~~~~~javascript
C = [[1,2,3],[4,5,6]]
D = [[1,2],[4,5],[7,8]]
MATPROD [C,D]
// => [ [30,36], [66,81] ]
~~~~~~~~~javascript



## Plasm.js: Exercise 8 (some array operators) 

Look at some PLaSM operators on *arrays*

~~~~~~~~~javascript
REPEAT(3) 0   # Repeat
// => [0,0,0]
REPEAT(3) [0,1]
// => [ [0,1], [0,1], [0,1] ]

REPLICA(3) [0,1]  # REPeat LIst & CAtenate
// => [ 0,1, 0,1, 0,1 ]
~~~~~~~~~javascript

~~~~~~~~~javascript
AR [ [0,0,0], 1 ]  # Append Rigth
// => [0,0,0,1]

AL [ 1, [0,0,0] ] # Append Left
// => [1,0,0,0]
~~~~~~~~~javascript



## Plasm.js: Exercise 9 (identity array) 

Write a function to generate the $n\times n$ identity matrix $[\T{I}]$

~~~~~~~~~javascript
IDNT = (n) ->  
	MAT(n,n) AR [REPLICA(n-1)(AL [1, REPEAT(n) 0]), 1]

IDNT 3 
// => [ [1,0,0], [0,1,0], [0,0,1] ]
~~~~~~~~~javascript

note that:

~~~~~~~~~javascript
MAT(2,3)([1,2,3,4,5,6])
// => [ [1,2,3], [4,5,6] ]

MAT(2,3)("ABCDEF")
// => [ ["A","B","C"], ["D","E","F"] ]
~~~~~~~~~javascript




## Basic use of PLaSM.js

~~~~~~~~~~~~~~~~~~~~python
# Execution initialization.
# The parameter `rn` is the dimension of the point space.
# Set `rn` to 2 for a 2D example.
rn = 3

# `points` to be classified are randomly generated, and their space is centered about the origin
# via the translation method `.t()`
points = randomPoints(rn, m=2000*Math.pow(2,rn), scale=8).t( [0...rn], REPEAT(rn)(-scale/2) )

# The `object` to draw is initialized to the empty array
object = SimplicialComplex [points, AA(list) [0...points.length]]

# The `draw` method of the `viewer` is applied to the `object` array, producing a `model` array. 
model = viewer.draw object
~~~~~~~~~~~~~~~~~~~~


## Setting the environment for PLaSM.js

#. Download `plasm.js` from the repository:

~~~~~~~~~~~~~~~~~~~~
git clone git://github/ ...
~~~~~~~~~~~~~~~~~~~~

#. Move in the `test` directory, and set `Ã¬ndex.html` to this content:

~~~~~~~~~~~~~~~~~~~~
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>test</title>
</head>
~~~~~~~~~~~~~~~~~~~~


## continue ...

#. continue ...

~~~~~~~~~~~~~~~~~~~~
<body>
  <script src="../support/numeric.js"></script>
  <script src="../support/three.js"></script>
  <script src="../support/detector.js"></script>
  <script src="../support/request-animation-frame.js"></script>
  <script src="../support/stats.js"></script>
  <script src="../lib/enhancedtrackballlightcontrols.js"></script>
  <script src="../lib/plasm.js"></script>
  <script src="../lib/plasm-init.js"></script>
  <script src="../lib/simplexn.js"></script>
  <script src="../test/jourfile.js"></script>
</body>
</html>
~~~~~~~~~~~~~~~~~~~~



## Plasm.js: Exercise 11  (VECTPROD)

the vector product $\v{w}$ of vectors in $\R^3$ id defined as the function
$$
\R^3\times \R^3\rightarrow\R^3 : (\v{u}, \v{v}) \mapsto \det\mat{
	\v{e}_0 & \v{e}_1 & \v{e}_2 \\
	{u}_x & {u}_y & {u}_z \\
	{v}_x & {v}_y & {v}_z \\
	}
$$
Therefore we can write, for the vector product of two 3D vector:

~~~~~~~~~~~~~~~~~javascript
VECTPROD = ([u,v]) ->
	w = new Array(3)
	w[0] = u[0]*v[1] - u[1]*v[0] 
	w[1] = u[2]*v[0] - u[0]*v[2] 
	w[2] = u[0]*v[2] - u[2]*v[0] 
	w

VECTPROD [[1,0,0], [0,1,0]]
\\ => [0,0,1]
VECTPROD [[1,1,0], [0,1,0]]
\\ => [0,0,1]
~~~~~~~~~~~~~~~~~javascript



## Plasm.js: Exercise 12 (1/4)

\small

~~~~~~~~~javascript
randomPoints = (m, sx=1, sy=1) ->
	point = () -> [Math.random() * sx, Math.random() * sy]
	new PointSet( point() for k in [0...m] )

points = randomPoints(200, 2*Math.PI, 2)
obj = new SimplicialComplex points.verts, AA(LIST) [0...points.m] 

model = viewer.draw obj
~~~~~~~~~javascript


## Plasm.js: Exercise 12 (2/4)

\normalsize


\begin{figure}
\centerline{\includegraphics[width=\linewidth]{figs/domain.pdf}}
\caption{200 random points in $[0,2\pi] \times [0,2] \subset\E^2$}
\end{figure}


## Plasm.js: Exercise 12 (3/4)

### coordinate functions

~~~~~~~~~javascript
x = ([u,v]) -> v * Math.cos u
y = ([u,v]) -> v * Math.sin u
obj = MAP([ x,y ]) obj

model = viewer.draw obj
~~~~~~~~~javascript



## Plasm.js: Exercise 12 (4/4)

\begin{figure}
\centerline{\includegraphics[width=0.6\linewidth]{figs/points.pdf}}
\caption{200 random points within the 2D "ball" of radius 2}
\end{figure}




## Plasm.js: Exercise 13 (4/4)

Map the previously constructed 2D random points to affine coordinates

~~~~~~~~~javascript



~~~~~~~~~javascript



## Plasm.js:  Exercise 14 (implement the Gift wrapping in 2D)

Of course, you need to draw your input data and your partial geometric constructions, in order to write and to test your algorithm ... :o)




## Current plasm.js Library

\tiny
\fourcolumns{
	AA\\
	AL\\
	APPLY\\
	AR\\
	BIGGER\\
	BIGGEST\\
	BOUNDARY\\
	BUTLAST\\
	CART\\
	CAT\\
	CENTROID\\
	CIRCLE\\
	CLONE\\
	CODE\\
	COMP\\
	CONS\\
	CUBE\\
	CUBOID\\
	CYLSOLID\\
	CYLSURFACE\\
	DISK\\
	DISTL\\
	DISTR\\
	DIV\\
}{
	EMBED\\
	EXPLODE\\
	EXTRUDE\\
	FIRST\\
	FREE\\
	Graph\\
	GRAPH\\
	HELIX\\
	ID\\
	IDNT\\
	IDNT\\
	INNERPROD\\
	INSL\\
	INSR\\
	INTERVALS\\
	INV\\
	ISFUN\\
	ISNUM\\
	K\\
	LAST\\
	LEN\\
	LINSPACE1D\\
	LINSPACE2D\\
	LINSPACE3D\\
}{
	LIST\\
	MAP\\
	MAT\\
	MATPROD\\
	MATSUM\\
	MUL\\
	PointSet\\
	POLYLINE\\
	POLYMARKER\\
	PRECISION\\
	PRINT\\
	PROD\\
	PROGRESSIVE\_SUM\\
	QUADMESH\\
	R\\
	REPEAT\\
	REPLICA\\
	REVERSE\\
	S\\
	S0\\
	S1\\
	S2\\
	S3\\
	S4\\
}{
	SET\\
	SIMPLEX\\
	SIMPLEXGRID\\
	SimplicialComplex\\
	SKELETON\\
	SMALLER\\
	SMALLEST\\
	SORTED\\
	SUB\\
	SUM\\
	T\\
	TAIL\\
	Topology\\
	TORUSSOLID\\
	TORUSSURFACE\\
	TRANS\\
	TREE\\
	TRIANGLEARRAY\\
	TRIANGLEFAN\\
	TRIANGLESTRIP\\
	UNITVECT\\
	VECTNORM\\
	VECTPROD\\
}
